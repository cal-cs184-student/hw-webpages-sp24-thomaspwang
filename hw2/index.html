<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c0{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c4{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c5{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c3{font-weight:700}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c5 doc-content"><a href="https://cal-cs184-student.github.io/hw-webpages-sp24-thomaspwang/">Link to the webpage</a><p class="c2"><span class="c0">Overview</span></p><p class="c2"><span class="c4">In this homework, I implemented Bezier using de Casteljau algorithm and extended it naturally to 2D surfaces. I also implemented area-weighted normal vectors to aid with Phong shading to make mesh lighting smoother. I then moved on to working with the half-edge data structure, where I implemented edge flips and edge splits. Lastly, I combined edge flip and edge split operations to implement the loop subdivision algorithm for mesh upsampling. I thought the most interesting thing about working on this project was the ingenuity of the half-edge data structure; although seemingly arbitrary to me at first, it become clear the more I worked with it how useful and intuitive it was for implementing mesh traversal algorithms. I also learned that pre-planning my algorithms with diagrams proved much more useful than trying to imagine it in my head.</span></p><p class="c1"><span class="c4"></span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c3">Part 1<br></span><span class="c4">De Casteljau&rsquo;s algorithm relies on recursively applying linear interpolation on subdivisions of the control points until one point remains. The collection of these final points generated by using different values of t from 0 to 1 results in the desired B&eacute;zier curve. I implemented it by filling out a function that, given a vector of points, evaluates the intermediate points given t. </span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 421.33px;"><img alt="" src="images/image15.png" style="width: 624.00px; height: 421.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 430.67px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 430.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 428.00px;"><img alt="" src="images/image1.png" style="width: 624.00px; height: 428.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 428.00px;"><img alt="" src="images/image9.png" style="width: 624.00px; height: 428.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 429.33px;"><img alt="" src="images/image4.png" style="width: 624.00px; height: 429.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 422.67px;"><img alt="" src="images/image12.png" style="width: 624.00px; height: 422.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c0">Part 2</span></p><p class="c2"><span class="c4">De Casteljau&#39;s algorithm extends to B&eacute;zier surfaces by applying the same principle used for B&eacute;zier curves but in two dimensions. A B&eacute;zier surface is defined by a grid of control points, with each point influencing the shape of the surface. The algorithm evaluates the surface at a given point by performing linear interpolations in both the u and v parameters, which correspond to the two dimensions of the surface. I implemented this by evaluating all the final points for each row of the control points grid at u and thus reducing the 2D grid to a 1D array of points, and then I find the final point on the surface by evaluadting that 1D array at v.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 424.00px;"><img alt="" src="images/image6.png" style="width: 624.00px; height: 424.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c0">PART 3</span></p><p class="c2"><span>I implemented the area-weighted vertex normals by calculating the cross-product between the vectors (V1 - V0) and (V2 - V1). Apparently,</span><span class="c3">&nbsp;</span><span class="c4">according to ed, the cross-product is already proportional to to triangle area, so there was no need to divide by area.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 332.00px;"><img alt="" src="images/image5.png" style="width: 624.00px; height: 332.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 372.00px;"><img alt="" src="images/image7.png" style="width: 624.00px; height: 372.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Part 4</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 310.67px;"><img alt="" src="images/image14.png" style="width: 624.00px; height: 310.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 329.33px;"><img alt="" src="images/image2.png" style="width: 624.00px; height: 329.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c4">I drew out every vertex and half-edge before and after the flip operation; I implemented it by just reassigning every pointer chance that I deduced from my drawing. At first, I screwed up by trying to do the flips in-line (i.e e0-&gt;halfedge()-&gt;next()-&gt;next() = e0-&gt;halfedge()-&gt;twin()-&gt;next()), but that was just impossible to debug and it broke like crazy. As a result, I assigned variables to every variable and half-edge and simply just re-assigned them as needed. For debugging techniques, I found using the VSCode &ldquo;Debug &amp; Run&rdquo; command very useful for debugging segfaults since it would show you the exact line of the crash.</span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c0">Part 5</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 298.67px;"><img alt="" src="images/image11.png" style="width: 624.00px; height: 298.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 292.00px;"><img alt="" src="images/image10.png" style="width: 624.00px; height: 292.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c4">I implemented the edge split operation by first creating the new vertex, edges, and half-edges, and then I used the same method and pattern from part 4: I assigned pointers according to this diagram that I made in the order recommended by the spec. In a spectacular miracle, &nbsp;I managed to get it right on the first try, so I didn&rsquo;t need any debugging tricks.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 364.00px;"><img alt="" src="images/image16.png" style="width: 624.00px; height: 364.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 416.00px;"><img alt="" src="images/image13.png" style="width: 624.00px; height: 416.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 348.00px;"><img alt="" src="images/image8.png" style="width: 624.00px; height: 348.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c0">Part 6</span></p><p class="c2"><span class="c4">I implemented loop subdivision by first computing all the new positions of new and old vertices and storing them in temp variables. Then I split every single edge (and updated the new middle vertex value from my previous calculations), and then for every edge that isn&rsquo;t new (i.e an edge that didn&rsquo;t make up the edge that was split), I checked to see if it connected a new and old vertex, and if it did, I flipped it. Lastly, I updated all the old vertices that were apart of the original mesh based on the calculations from the first step. </span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c4">Unlike the spectacular miracle I experienced in part 5, this took an extremely long time to debug. My biggest issue was that I was attempting to split edges inside a for loop, which caused crashes or infinite loops since splitting edges alters the mesh edges list. To fix this, I just created a new vector containing only the original edges. </span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c4">I noticed that sharp corners and edges become smoother after subdivisions.I notice that the more I pre-split that edge, the sharper the feature remains after subdivisioning.</span></p><p class="c1"><span class="c4"></span></p><p class="c2"><span class="c4">I think the cube becomes asymmetric since the triangle mesh on the cube is asymmetric, which compounds after a few iterations of subdivisioning. If I split edges on the cube such that every face is an &ldquo;X&rdquo; instead of a &ldquo;\&rdquo;, then the subdivisioned cube is also symmetric.</span></p><img src="./images/part6.1.png">
    <img src="./images/part6.2.png">
    <img src="./images/part6.3.png"></body></html>