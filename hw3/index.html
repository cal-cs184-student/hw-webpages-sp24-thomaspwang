<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url(https://themes.googleusercontent.com/fonts/css?kit=ybEf4BSnVR9aG_hb6np12LlXFg04YLsiX7TbaK3VchI);.lst-kix_5zaugujqpzoy-3>li:before{content:"\0025cf   "}ul.lst-kix_5zaugujqpzoy-8{list-style-type:none}ul.lst-kix_5zaugujqpzoy-7{list-style-type:none}.lst-kix_5zaugujqpzoy-2>li:before{content:"\0025a0   "}.lst-kix_5zaugujqpzoy-6>li:before{content:"\0025cf   "}ul.lst-kix_5zaugujqpzoy-2{list-style-type:none}ul.lst-kix_5zaugujqpzoy-1{list-style-type:none}ul.lst-kix_5zaugujqpzoy-0{list-style-type:none}.lst-kix_lvjhhgnhyfdv-0>li:before{content:"\0025cf   "}.lst-kix_5zaugujqpzoy-5>li:before{content:"\0025a0   "}ul.lst-kix_5zaugujqpzoy-6{list-style-type:none}ul.lst-kix_5zaugujqpzoy-5{list-style-type:none}.lst-kix_5zaugujqpzoy-4>li:before{content:"\0025cb   "}ul.lst-kix_5zaugujqpzoy-4{list-style-type:none}ul.lst-kix_5zaugujqpzoy-3{list-style-type:none}.lst-kix_lvjhhgnhyfdv-1>li:before{content:"\0025cb   "}ul.lst-kix_lvjhhgnhyfdv-5{list-style-type:none}ul.lst-kix_lvjhhgnhyfdv-6{list-style-type:none}ul.lst-kix_lvjhhgnhyfdv-7{list-style-type:none}ul.lst-kix_lvjhhgnhyfdv-8{list-style-type:none}.lst-kix_5zaugujqpzoy-1>li:before{content:"\0025cb   "}ul.lst-kix_lvjhhgnhyfdv-1{list-style-type:none}ul.lst-kix_lvjhhgnhyfdv-2{list-style-type:none}.lst-kix_5zaugujqpzoy-0>li:before{content:"\0025cf   "}ul.lst-kix_lvjhhgnhyfdv-3{list-style-type:none}ul.lst-kix_lvjhhgnhyfdv-4{list-style-type:none}ul.lst-kix_lvjhhgnhyfdv-0{list-style-type:none}.lst-kix_lvjhhgnhyfdv-7>li:before{content:"\0025cb   "}.lst-kix_lvjhhgnhyfdv-8>li:before{content:"\0025a0   "}.lst-kix_lvjhhgnhyfdv-2>li:before{content:"\0025a0   "}.lst-kix_lvjhhgnhyfdv-3>li:before{content:"\0025cf   "}.lst-kix_5zaugujqpzoy-7>li:before{content:"\0025cb   "}.lst-kix_lvjhhgnhyfdv-6>li:before{content:"\0025cf   "}.lst-kix_lvjhhgnhyfdv-4>li:before{content:"\0025cb   "}.lst-kix_5zaugujqpzoy-8>li:before{content:"\0025a0   "}.lst-kix_lvjhhgnhyfdv-5>li:before{content:"\0025a0   "}ol{margin:0;padding:0}table td,table th{padding:0}.c10{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c11{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"PT Serif";font-style:normal}.c5{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Arial";font-style:normal}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Arial";font-style:normal}.c12{padding-top:20pt;padding-bottom:12pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c0{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"PT Serif";font-style:normal}.c9{padding-top:0pt;padding-bottom:12pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c7{color:#000000;text-decoration:none;vertical-align:baseline;font-size:11pt;font-style:italic}.c13{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c8{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c6{font-weight:400;font-family:"PT Serif"}.c4{color:inherit;text-decoration:inherit}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c8 doc-content"><p class="c2"><span class="c6 c13"><a class="c4" href="https://www.google.com/url?q=https://cal-cs184-student.github.io/hw-webpages-sp24-thomaspwang/&amp;sa=D&amp;source=editors&amp;ust=1710627887275470&amp;usg=AOvVaw2acw9xogZMpgc6M9hHF6co">https://cal-cs184-student.github.io/hw-webpages-sp24-thomaspwang/</a></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c6">This project, I implemented ray generation and scene intersection with triangle and spheres, created the bounding volume hierarchy data structure for faster insection checks, implemented different kinds of direct illumination (zero bounce, uniform hemisphere sampling, direct lighting importance), global illumination, and adaptive sampling. </span></p><h1 class="c10" id="h.96vc81anmmn5"><span class="c3">Part 1</span></h1><p class="c1"><span class="c11"></span></p><p class="c2"><span class="c0">For ray generation, &nbsp;I computed the horizontal and vertical FOV in radians and calculated the positions of the bottom-left and top-right corners of the sensor plane according to the following formulas:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Vector3D bottom_left = Vector3D(-tan(radians(hFov) * 0.5), -tan(radians(vFov) * &nbsp;0.5), -1);</span></p><p class="c2"><span class="c6 c7">Vector3D top_right = Vector3D(tan(radians(hFov) * 0.5), tan(radians(vFov) * &nbsp;0.5), -1);</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Then, I used linear interpolation to find the point on the sensor plane that corresponded to the inputs (x, y) using the following equations:</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">double interp_x = (top_right.x - bottom_left.x) * x + bottom_left.x;</span></p><p class="c2"><span class="c0">double interp_y = (top_right.y - bottom_left.y) * y + bottom_left.y;</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Lastly, I applied the camera-to-world rotation matrix to the normalized vector from the interpolated points to transform the ray to world space.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">I used this ray generation to be able to sample pixels; specifically, for each pixel, I sampled random rays from adding a ([0, 1), [0, 1)) uniformly distributed vector to the normalized position in image space (since it&rsquo;s bottom left), and then averaged them to estimate the true scene radiance for that pixel.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">To implement triangle intersection, I used the M&ouml;ller-Trumbore algorithm. To check if a ray intersects the triangle, we first check if the determinant is super close to 0; if so, then the ray is parallel and therefore no intersection. Using the inverse determinant, we can calculate the baryucentric coordinates &lsquo;u&rsquo; and &lsquo;v&rsquo;. If either coordinate is outside the raange [0, 1] or their sum exceeds 1, then the intersection point is outside of the triangle. If the distance parameter &lsquo;t_value&rsquo; is not within the valid range of the ray, then the ray doesn&rsquo;t actually exist when intersecting the triangle. By using the barycentric coordinates, we calculate the surface normal and update the intersection data structure accordingly along with the t_value, the intersected triangle, and the BSDF.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">To implement sphere intersection, I check if an intersection exists by solving the discriminant for the quadratic equation in class. If the discriminant is less than 0, then there are no intersections. When there are two intersections, I set the t value to the closest intersection that is within the min_t and max_t range of the ray. And then I fill in the intersection data structure, like the triangle part, except that the surface normal is the normalized vector pointing from the sphere center to the intersection point.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 522.00px; height: 393.00px;"><img alt="" src="images/image10.png" style="width: 522.00px; height: 393.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c5"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 505.00px; height: 356.00px;"><img alt="" src="images/image31.png" style="width: 505.00px; height: 356.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 501.00px; height: 384.00px;"><img alt="" src="images/image27.png" style="width: 501.00px; height: 384.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><h1 class="c10" id="h.xhycnlarp8w6"><span class="c3">Part 2</span></h1><p class="c2"><span class="c0">To construct a bounded volume hierarchy, my heuristic for picking the splitting point was choosing the medium primitive on the axis with the largest extent. &nbsp;To do this, I computed the axis with the largest extent, and then created a lambda function that compares primitives based on their centroids on the given axis. Then, I passed that lambda function into the nth_element sorting function that changed the start, mid, and end iterators to be sorted based on selected axis. Then, I recursively called construct_bvh to build the left_child and right_child bounded volume hierarchies. </span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 474.67px;"><img alt="" src="images/image12.png" style="width: 624.00px; height: 474.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 462.67px;"><img alt="" src="images/image19.png" style="width: 624.00px; height: 462.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 457.33px;"><img alt="" src="images/image8.png" style="width: 624.00px; height: 457.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">Previously, the cow (dae/meshedit/cow.dae) took around 13.5 seconds to render with an average around 815 intersection tests per ray. With BVH acceleration, that shortened to 0.03 seconds to render with an average of 0.03 seconds to render with an average of around 3 intersection tests per ray, which is a huge improvement. Previously, the spheres (dae/sky/CBspheres.dae) took &nbsp;around 0.04 seconds to render with an average of 2.89 intersection tests per ray. With BVH acceleration, that shortened the rendering time to around 0.02 seconds with an average of 1.54 intersection tests per ray. The reason for the dramatic difference in speedups lies in the fact that BVH acceleration only drastically improves rendering performance when there are a lot of primitives to process. The spheres have 14 primities, while the cow has 5856 primitives; as a result, optimizing the ray search space for the cow results in a dramatic difference in the number of primitive intersections to check, whereas it doesn&rsquo;t for the sphere.</span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><h1 class="c10" id="h.yjxe6gbj8k0v"><span class="c3">Part 3</span></h1><p class="c2"><span class="c0">To implement direct lighting with uniform hemisphere sampling, I generated num_samples amount of rays with a random direction from the unit hemisphere originating from hit_p. For each of those rays, I check if it intersects with any primitives; if so, then we estimate the amount of light arriving from that ray from solving the reflection equation using a Monte Carlo estimator. After that, we add these light values into an accumulator thata we return after dividing it by the number of samples.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">To implement direct lighting by importance, for every light source in the scene, I generated &lsquo;shadow rays&rsquo; between the hit point and the light source. If there wasn&rsquo;t an intersection (i.e no objects between the hit point and the light source), then we would add the result of the reflectance equation to our light accumulator variable (weighted by the number of samples for that light source). Unlike uniform hemisphere sampling, instead of using the bsdf for the emitted light value, we used the radiance that we got from sampling the light. As an optimization, if a light source is a point light source, I would sample it only once (since all samples from a point light would be the same).</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Below: Lighting by importance</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image4.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c6">Below: Uniform hemisphere sampling<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image22.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c6">Below: Lighting by importance<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 480.00px;"><img alt="" src="images/image20.png" style="width: 480.00px; height: 480.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c6">Below: 1 sample per pixel, 1 light ray<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image30.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">Below: 1 sample per pixel, 4 light rays</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image34.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">Below: 1 sample per pixel, 16 light rays</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image1.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Below: 1 sample per pixel, 64 light rays</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image32.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">Here, you can see that increasing light rays significantly refined the image quality by reducing noise. This is because of the increased likelihood of shadow rays successfully reaching the light source, rather than being blocked by an object (aka the &lsquo;grain&rsquo;), as we increase the number of light rays.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">In comparing uniform hemisphere sampling to light sampling, we can see that uniform sampling creates more noise since it outputs rays at random that sometimes don&rsquo;t intersect with anything. Also, hemisphere sampling does really poorly with point light sources, since it&rsquo;s really unlikely that samples will hit them. Light sampling is also more efficient, since it&rsquo;s more likely that generated sample rays actually contribute light information to the final image; in construct, it&rsquo;s more likely (due to randomness) that hemisphere sampling will generate a ray that doesn&rsquo;t contribute any information. </span></p><p class="c1"><span class="c0"></span></p><h1 class="c10" id="h.t2k0iroc7uhf"><span class="c3">Part 4</span></h1><p class="c2"><span class="c0">To implement indirect lighting, I filled in the recursive function &lsquo;at_least_one_bounce_radiance&rsquo;. There are two base cases. If the depth of the current ray is 0, then we return nothing because we&rsquo;re beyond the ray&rsquo;s max depth. If the depth of the current ray is 1, then we return the result of &lsquo;one_bounce_radiance&rsquo;, since it&rsquo;s the ray&rsquo;s last bounce and thus is the &lsquo;source&rsquo; light ray. Otherwise, we create a new ray originating from the hit point with a wi based on sampling from the current intersection&rsquo;s bsdf, and if an intersection exists, then we get the radiance value from a recursive call to &lsquo;at_least_one_bounce_radiance&rsquo;, and we plug that into our reflection equation like before. Also, if there is an intersection of the newly created ray, there&rsquo;s a 30% probability that it terminates for feasibility purposes in cases of large ray max depth sizes.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c6">Here are a couple images with global illuminate at 1024 samples per pixel.<br></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image17.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image9.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">Here&rsquo;s bunny with only direct illumination with 1024 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image9.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">Here&rsquo;s bunny with only indirect illumination with 1024 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image14.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c6">The following are CBunny.dae with isAccumBounces off with the max ray depth to 0, 1, 2, 3, 4, and 5 in that order. 1024 samples per pixels and 16 light rays.</span><hr style="page-break-before:always;display:none;"></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image11.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image37.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image28.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image6.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image21.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image21.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">We can see from the second and third light bounces that it adds nuances that rasterization could not. Soft shadows become softer, and the light in the scene more closely mimics how it behaves in reality, contributing to the overall believability of the rendered image. We can see in the second bounce that it shows the light that bounces off the ground, bouncing off the under areas of the bunny. We can see in the third bounce that it&rsquo;s dark since most of the light would not have continued to bounce by the third one, but you can still see a slight contour of the bunny.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">The following are CBunny.dae with isAccumBounces on with the max ray depth to 0, 1, 2, 3, 4, 5, and 100 &nbsp;in that order. 1024 samples per pixels and 16 light rays.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image24.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image5.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image25.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image25.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image7.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image36.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image15.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span class="c0">The changes in these renders diminish as your increase the number of bounces (the most significant changes are from m=0 to m=1, or m=1 to m=2), since not very much light remains to be accumulated after a few bounces. But you can see the lighting complexity increase as the number of bounces increases.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">The following are renders of CBSphere_lambertion with 1, 2, 4, 8, 16, and 1024 samples per pixel in that order with 4 light rays.</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image13.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image13.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image33.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image16.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image18.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image26.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image35.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c9"><span class="c0">When the number of samples-per-pixel increases, the image quality increases and becomes less noisy since having a sample rate results in a higher probability of rendering the light precisely at every hit point.</span></p><h1 class="c12" id="h.nwsyvbba497f"><span class="c3">Part 5</span></h1><p class="c2"><span class="c0">Adaptive sampling allocates more sampling resources to regions of an image with higher visual complexity and fewer samples to simpler areas, which optimizes computational effort. This method enhances image quality where it&#39;s most needed, such as in areas with sharp edges or high contrast, while reducing render times compared to uniformly sampling the entire image. To implement this, for every &lsquo;batch_count&rsquo; number of samples, I would perform a check to see if a pixel &lsquo;converged&rsquo;. I did this check by calculating the mean, variance, and variable I (defined as 1.96 * sqrt(variance / number of samples so far). If this variable was less than the maxTolerance * mean, then we say the pixel converged and we stop sampling for that pixel.</span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Bunny rendered at 2048 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image23.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c6">Sampling rate image:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image2.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Spheres rendered at 2048 samples per pixel:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image3.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c2"><span class="c0">Sampling rate image:</span></p><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 480.00px; height: 360.00px;"><img alt="" src="images/image29.png" style="width: 480.00px; height: 360.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c0"></span></p><p class="c1"><span class="c0"></span></p><div><p class="c1"><span class="c5"></span></p></div></body></html>